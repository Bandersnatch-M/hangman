def hangman(word):
    wrong = 0 # кол-во не правильных предположений
    stages = ["",                   # Строки вывода виселицы (список)
              "________        ",
              "|       |       ",
              "|       |       ",
              "|       0       ",
              "|      /|\      ",
              "|      / \      ",
              "|               "] 

    rletters = list(word) # список букв в слове word
    board = ["__"]*len(word) # список строк "__" в слове word
    win = False
    print("Welcome for the execution!")
    while wrong < len(stages) - 1:
        print("\n")
        msg = "Enter a letter: "
        guess = input(msg)
        
# Нужен цикл, чтобы определить есть буква в слове или нет и ввести следующую.
"""
Работает так, если буква (guess) есть в слове (rletters):
1. Мы присваиваем номер индекса этой буквы переменной letter_index;
2. За счет возможности присовоить индекс в списке новому объекту используем это
свойтство списка для замены "__" по индексу в списке board на угаданную букву.
Для этого необходимо !!!сначала указать индекс списка board[letter_index] и с
помощью "=" присвоить ему значение guess. Таким образом нужная буква в списке
board будет показана игроку.
3. Поскольку index возвращает только первый индекс искомого символа, код не
будет работать, если переменная word содержит повторяющиеся символы. Чтобы
обойти это, необходимо измените список rletters, заменив правильно угаданный
символ каким нибудь не буквенным значением, например - знаком доллара.
Таким образом, при следующем прохождении цикла функция index найдет следующее
вхождение буквы (если оно есть), а не остановится на первом вхождении.
"""
    if guess in rletters:
        letter_index = rletters.index(guess)
        board[letter_index] = guess
        rletters[letter_index] = '$'
"""
Если буквы (guess) нет в слове (rletters):
1. Увеличиваем переменную wrong на 1
2. Выводим результат угадывания (через board) и висилецу (через stages)
Код для board - "  ".join(board);
Код для stages - "\n".join(stages[0:e]), e = wrong + 1 на данной стадии
(т.е. используется срез списка на данной стадии).
"""
    else:
        wrong += 1
    print(("  ".join(board)))
    e = wrong + 1
    print("\n".join(stages[0:e]) 
"""
Проверяем, победил ли второй игрок: Если в списке board больше нет нижних подчерки-
ваний "__", значит, игрок отгадал все буквы и победил. Если второй игрок победил,
выводится строка "You win! The word is: " и правильно отгаданное слово.
Также необходимо присвоить переменной win значение True, чтобы прервать цикл.
"""
        if "__" not in board:
              print ("You win! The word is: ")
              print ("  ".join(board))
              win = True
              break
"""
Если игрок проиграл, значение переменной win = False — в этом случае, выводится рисунок
висельника полностью и строка "Game over. You are executed! The word was: {}.".format(word) с указанием
слова, которое игрок не угадал, при помощи метода foramt.
{} - в эти кавычки вставляется значение word, указанное в скобках после format.
"""
    if not win:
        print("\n".join(stages[0:wrong]))
        print("Game over. You are executed! The word was: {}.".format(word))
        

hangman("home")
